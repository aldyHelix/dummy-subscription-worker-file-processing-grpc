// Code generated by github.com/citradigital/toldata. DO NOT EDIT.
// package: copyfto
// source: copyfto.proto


package copyfto
import (
	"context"
	"errors"
   io "io"
	"github.com/gogo/protobuf/proto"
	"github.com/citradigital/toldata"
	nats "github.com/nats-io/go-nats"
	"reflect"
)

// Workaround for template problem
func _eof() error {
	return io.EOF
}




type CopyftoToldataInterface interface {
	ToldataHealthCheck(ctx context.Context, req *toldata.Empty) (*toldata.ToldataHealthCheckInfo, error)

	



	
		CopyFileDummyOrder(ctx context.Context, req *Empty) (*GenericReponse, error)
	
}

type CopyftoToldataClient struct {
	Bus *toldata.Bus
	
	Service CopyftoToldataInterface
	
}

type CopyftoToldataServer struct {
	Bus *toldata.Bus
	Service CopyftoToldataInterface
}

func NewCopyftoToldataClient(bus *toldata.Bus) * CopyftoToldataClient {
	s := &CopyftoToldataClient{ Bus: bus }
	return s
}

func (service *CopyftoToldataClient) SetBuslessObject(target CopyftoToldataInterface) error {
	e := reflect.ValueOf(service).Elem()
     
  for i := 0; i < e.NumField(); i++ {
	   varName := e.Type().Field(i).Name
		 if varName == "Service" {
			   service.Service = target
				 return nil
		 }
	}
	return errors.New("Not in busless mode")
}


func NewCopyftoToldataServer(bus *toldata.Bus, service CopyftoToldataInterface) * CopyftoToldataServer {
	s := &CopyftoToldataServer{ Bus: bus, Service: service }
	return s
}

func (service *CopyftoToldataClient) ToldataHealthCheck(ctx context.Context, req *toldata.Empty) (*toldata.ToldataHealthCheckInfo, error) {

  return service.Service.ToldataHealthCheck(ctx, req)

}



	





func (service *CopyftoToldataClient) CopyFileDummyOrder(ctx context.Context, req *Empty) (*GenericReponse, error) {

  return service.Service.CopyFileDummyOrder(ctx, req)

}









func (service *CopyftoToldataServer) SubscribeCopyfto() (<-chan struct{}, error) {
	bus := service.Bus
	
	var err error
	var sub *nats.Subscription
	var subscriptions []*nats.Subscription
	
	done := make(chan struct{})
	
		



	
	sub, err = bus.Connection.QueueSubscribe("copyfto/Copyfto/CopyFileDummyOrder", "copyfto/Copyfto", func(m *nats.Msg) {
		var input Empty
		err := proto.Unmarshal(m.Data, &input)
		if err != nil {
			bus.HandleError(m.Reply, err)
			return
		}
		result, err := service.Service.CopyFileDummyOrder(bus.Context, &input)

		if m.Reply != ""  {
			if err != nil {
				bus.HandleError(m.Reply, err)
			} else {
				raw, err := proto.Marshal(result)
				if err != nil {
					bus.HandleError(m.Reply, err)
				} else {
					zero := []byte{0}
					bus.Connection.Publish(m.Reply, append(zero, raw...))
				}
			}
		}

	})

	subscriptions = append(subscriptions, sub)
	



	


	sub, err = bus.Connection.QueueSubscribe("copyfto/Copyfto/ToldataHealthCheck", "copyfto/Copyfto", func(m *nats.Msg) {
		var input toldata.Empty
		err := proto.Unmarshal(m.Data, &input)
		if err != nil {
			bus.HandleError(m.Reply, err)
			return
		}
		result, err := service.Service.ToldataHealthCheck(bus.Context, &input)

		if m.Reply != ""  {
			if err != nil {
				bus.HandleError(m.Reply, err)
			} else {
				raw, err := proto.Marshal(result)
				if err != nil {
					bus.HandleError(m.Reply, err)
				} else {
					zero := []byte{0}
					bus.Connection.Publish(m.Reply, append(zero, raw...))
				}
			}
		}

	})

	subscriptions = append(subscriptions, sub)


	go func() {
		defer close(done)

		select {
		case <-bus.Context.Done():
			for i := range subscriptions {
				subscriptions[i].Unsubscribe()
			}
		}
	}()

	return done, err
}






