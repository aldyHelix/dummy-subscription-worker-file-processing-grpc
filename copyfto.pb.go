// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: copyfto.proto

package copyfto

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// swagger:model Empty
type Empty struct {
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_4baead9d1ff0d4ce, []int{0}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(m, src)
}
func (m *Empty) XXX_Size() int {
	return m.Size()
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

// swagger:model GenericReponse
type GenericReponse struct {
	Success   bool   `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	RequestId string `protobuf:"bytes,2,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
}

func (m *GenericReponse) Reset()         { *m = GenericReponse{} }
func (m *GenericReponse) String() string { return proto.CompactTextString(m) }
func (*GenericReponse) ProtoMessage()    {}
func (*GenericReponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4baead9d1ff0d4ce, []int{1}
}
func (m *GenericReponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenericReponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenericReponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenericReponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenericReponse.Merge(m, src)
}
func (m *GenericReponse) XXX_Size() int {
	return m.Size()
}
func (m *GenericReponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GenericReponse.DiscardUnknown(m)
}

var xxx_messageInfo_GenericReponse proto.InternalMessageInfo

func (m *GenericReponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *GenericReponse) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

// swagger:model DummyOrderInfo
type DummyOrderInfo struct {
	// ID
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// nama_file
	FileName string `protobuf:"bytes,2,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
	// nomor_file
	FileNumber int64 `protobuf:"varint,3,opt,name=file_number,json=fileNumber,proto3" json:"file_number,omitempty"`
	// ukuran_file_normal
	NormalFileSize int64 `protobuf:"varint,4,opt,name=normal_file_size,json=normalFileSize,proto3" json:"normal_file_size,omitempty"`
	// ukuran_file_zip
	ZipFileSize int64 `protobuf:"varint,5,opt,name=zip_file_size,json=zipFileSize,proto3" json:"zip_file_size,omitempty"`
	// jumlah_transaksi
	NumberOfTransaction int64 `protobuf:"varint,6,opt,name=number_of_transaction,json=numberOfTransaction,proto3" json:"number_of_transaction,omitempty"`
	// tanggal_peroleh
	ObtainedDate int64 `protobuf:"varint,7,opt,name=obtained_date,json=obtainedDate,proto3" json:"obtained_date,omitempty"`
	// status_file
	FileStatus string `protobuf:"bytes,8,opt,name=file_status,json=fileStatus,proto3" json:"file_status,omitempty"`
}

func (m *DummyOrderInfo) Reset()         { *m = DummyOrderInfo{} }
func (m *DummyOrderInfo) String() string { return proto.CompactTextString(m) }
func (*DummyOrderInfo) ProtoMessage()    {}
func (*DummyOrderInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4baead9d1ff0d4ce, []int{2}
}
func (m *DummyOrderInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DummyOrderInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DummyOrderInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DummyOrderInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DummyOrderInfo.Merge(m, src)
}
func (m *DummyOrderInfo) XXX_Size() int {
	return m.Size()
}
func (m *DummyOrderInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DummyOrderInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DummyOrderInfo proto.InternalMessageInfo

func (m *DummyOrderInfo) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DummyOrderInfo) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

func (m *DummyOrderInfo) GetFileNumber() int64 {
	if m != nil {
		return m.FileNumber
	}
	return 0
}

func (m *DummyOrderInfo) GetNormalFileSize() int64 {
	if m != nil {
		return m.NormalFileSize
	}
	return 0
}

func (m *DummyOrderInfo) GetZipFileSize() int64 {
	if m != nil {
		return m.ZipFileSize
	}
	return 0
}

func (m *DummyOrderInfo) GetNumberOfTransaction() int64 {
	if m != nil {
		return m.NumberOfTransaction
	}
	return 0
}

func (m *DummyOrderInfo) GetObtainedDate() int64 {
	if m != nil {
		return m.ObtainedDate
	}
	return 0
}

func (m *DummyOrderInfo) GetFileStatus() string {
	if m != nil {
		return m.FileStatus
	}
	return ""
}

type DummyOrderInfoHistory struct {
	//ID
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// dummy_order_detail
	DummyOrderDetail string `protobuf:"bytes,2,opt,name=dummy_order_detail,json=dummyOrderDetail,proto3" json:"dummy_order_detail,omitempty"`
	// status_id
	StatusId string `protobuf:"bytes,3,opt,name=status_id,json=statusId,proto3" json:"status_id,omitempty"`
	// status_label
	StatusLabel string `protobuf:"bytes,4,opt,name=status_label,json=statusLabel,proto3" json:"status_label,omitempty"`
	// status_proses
	StatusProcess string `protobuf:"bytes,5,opt,name=status_process,json=statusProcess,proto3" json:"status_process,omitempty"`
	// deskripsi_status
	StatusDescription string `protobuf:"bytes,6,opt,name=status_description,json=statusDescription,proto3" json:"status_description,omitempty"`
}

func (m *DummyOrderInfoHistory) Reset()         { *m = DummyOrderInfoHistory{} }
func (m *DummyOrderInfoHistory) String() string { return proto.CompactTextString(m) }
func (*DummyOrderInfoHistory) ProtoMessage()    {}
func (*DummyOrderInfoHistory) Descriptor() ([]byte, []int) {
	return fileDescriptor_4baead9d1ff0d4ce, []int{3}
}
func (m *DummyOrderInfoHistory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DummyOrderInfoHistory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DummyOrderInfoHistory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DummyOrderInfoHistory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DummyOrderInfoHistory.Merge(m, src)
}
func (m *DummyOrderInfoHistory) XXX_Size() int {
	return m.Size()
}
func (m *DummyOrderInfoHistory) XXX_DiscardUnknown() {
	xxx_messageInfo_DummyOrderInfoHistory.DiscardUnknown(m)
}

var xxx_messageInfo_DummyOrderInfoHistory proto.InternalMessageInfo

func (m *DummyOrderInfoHistory) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *DummyOrderInfoHistory) GetDummyOrderDetail() string {
	if m != nil {
		return m.DummyOrderDetail
	}
	return ""
}

func (m *DummyOrderInfoHistory) GetStatusId() string {
	if m != nil {
		return m.StatusId
	}
	return ""
}

func (m *DummyOrderInfoHistory) GetStatusLabel() string {
	if m != nil {
		return m.StatusLabel
	}
	return ""
}

func (m *DummyOrderInfoHistory) GetStatusProcess() string {
	if m != nil {
		return m.StatusProcess
	}
	return ""
}

func (m *DummyOrderInfoHistory) GetStatusDescription() string {
	if m != nil {
		return m.StatusDescription
	}
	return ""
}

// swagger:model RequestInfo
type RequestInfo struct {
	RequestId string `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id,omitempty"`
	Username  string `protobuf:"bytes,2,opt,name=username,proto3" json:"username,omitempty"`
	Resource  string `protobuf:"bytes,3,opt,name=resource,proto3" json:"resource,omitempty"`
	Action    string `protobuf:"bytes,4,opt,name=action,proto3" json:"action,omitempty"`
	IpAddress string `protobuf:"bytes,5,opt,name=ip_address,json=ipAddress,proto3" json:"ip_address,omitempty"`
	Endpoint  string `protobuf:"bytes,6,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
}

func (m *RequestInfo) Reset()         { *m = RequestInfo{} }
func (m *RequestInfo) String() string { return proto.CompactTextString(m) }
func (*RequestInfo) ProtoMessage()    {}
func (*RequestInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4baead9d1ff0d4ce, []int{4}
}
func (m *RequestInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestInfo.Merge(m, src)
}
func (m *RequestInfo) XXX_Size() int {
	return m.Size()
}
func (m *RequestInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RequestInfo proto.InternalMessageInfo

func (m *RequestInfo) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *RequestInfo) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *RequestInfo) GetResource() string {
	if m != nil {
		return m.Resource
	}
	return ""
}

func (m *RequestInfo) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *RequestInfo) GetIpAddress() string {
	if m != nil {
		return m.IpAddress
	}
	return ""
}

func (m *RequestInfo) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func init() {
	proto.RegisterType((*Empty)(nil), "copyfto.Empty")
	proto.RegisterType((*GenericReponse)(nil), "copyfto.GenericReponse")
	proto.RegisterType((*DummyOrderInfo)(nil), "copyfto.DummyOrderInfo")
	proto.RegisterType((*DummyOrderInfoHistory)(nil), "copyfto.DummyOrderInfoHistory")
	proto.RegisterType((*RequestInfo)(nil), "copyfto.RequestInfo")
}

func init() { proto.RegisterFile("copyfto.proto", fileDescriptor_4baead9d1ff0d4ce) }

var fileDescriptor_4baead9d1ff0d4ce = []byte{
	// 543 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x53, 0xcd, 0x6e, 0xd3, 0x4c,
	0x14, 0x8d, 0xd3, 0x2f, 0x3f, 0xbe, 0x69, 0xf2, 0xd1, 0x89, 0x28, 0x56, 0x11, 0x26, 0x35, 0x42,
	0xca, 0x86, 0x2c, 0xca, 0x0b, 0xf0, 0x13, 0x7e, 0x22, 0x10, 0x45, 0x6e, 0x57, 0x6c, 0xac, 0x89,
	0xe7, 0x46, 0x1a, 0xc9, 0xf1, 0x0c, 0x33, 0xe3, 0x45, 0xf2, 0x14, 0xbc, 0x05, 0x8f, 0xc0, 0x2b,
	0xb0, 0xec, 0x92, 0x25, 0x4a, 0xf6, 0x3c, 0x03, 0xf2, 0x8c, 0x9d, 0xa4, 0x65, 0xe7, 0x7b, 0xce,
	0xd1, 0xb5, 0xce, 0x99, 0x73, 0xa1, 0x9f, 0x0a, 0xb9, 0x5a, 0x18, 0x31, 0x91, 0x4a, 0x18, 0x41,
	0x3a, 0xd5, 0x18, 0x75, 0xa0, 0xf5, 0x66, 0x29, 0xcd, 0x2a, 0x9a, 0xc1, 0xe0, 0x1d, 0xe6, 0xa8,
	0x78, 0x1a, 0xa3, 0x14, 0xb9, 0x46, 0x12, 0x40, 0x47, 0x17, 0x69, 0x8a, 0x5a, 0x07, 0xde, 0xc8,
	0x1b, 0x77, 0xe3, 0x7a, 0x24, 0x8f, 0x00, 0x14, 0x7e, 0x2d, 0x50, 0x9b, 0x84, 0xb3, 0xa0, 0x39,
	0xf2, 0xc6, 0x7e, 0xec, 0x57, 0xc8, 0x8c, 0x45, 0xdf, 0x9b, 0xf0, 0xff, 0x35, 0x95, 0xa8, 0xe8,
	0xa5, 0x62, 0xa8, 0x66, 0xf9, 0x42, 0x90, 0x01, 0x34, 0x39, 0xb3, 0x7b, 0xfc, 0xb8, 0xc9, 0x19,
	0x79, 0x08, 0xfe, 0x82, 0x67, 0x98, 0xe4, 0x74, 0x89, 0xd5, 0x86, 0x6e, 0x09, 0x7c, 0xa2, 0x4b,
	0x24, 0x8f, 0xa1, 0xe7, 0xc8, 0x62, 0x39, 0x47, 0x15, 0x1c, 0x8d, 0xbc, 0xf1, 0x51, 0x0c, 0x96,
	0xb6, 0x08, 0x19, 0xc3, 0xbd, 0x5c, 0xa8, 0x25, 0xcd, 0x12, 0xab, 0xd3, 0x7c, 0x8d, 0xc1, 0x7f,
	0x56, 0x35, 0x70, 0xf8, 0x5b, 0x9e, 0xe1, 0x15, 0x5f, 0x23, 0x89, 0xa0, 0xbf, 0xe6, 0xf2, 0x40,
	0xd6, 0xb2, 0xb2, 0xde, 0x9a, 0xcb, 0x9d, 0xe6, 0x02, 0xee, 0xbb, 0x3f, 0x25, 0x62, 0x91, 0x18,
	0x45, 0x73, 0x4d, 0x53, 0xc3, 0x45, 0x1e, 0xb4, 0xad, 0x76, 0xe8, 0xc8, 0xcb, 0xc5, 0xf5, 0x9e,
	0x22, 0x4f, 0xa0, 0x2f, 0xe6, 0x86, 0xf2, 0x1c, 0x59, 0xc2, 0xa8, 0xc1, 0xa0, 0x63, 0xb5, 0xc7,
	0x35, 0x38, 0xa5, 0x66, 0xef, 0x43, 0x1b, 0x6a, 0x0a, 0x1d, 0x74, 0xad, 0x4d, 0xeb, 0xe3, 0xca,
	0x22, 0xd1, 0x1f, 0x0f, 0x4e, 0xef, 0x24, 0xf5, 0x9e, 0x6b, 0x23, 0xd4, 0xea, 0x9f, 0xc0, 0x26,
	0x30, 0x34, 0x56, 0x99, 0x88, 0x52, 0x9a, 0x30, 0x34, 0x94, 0x67, 0x55, 0x74, 0x27, 0x66, 0xbf,
	0x64, 0x6a, 0x89, 0x32, 0x60, 0xf7, 0xdb, 0xf2, 0x89, 0x8e, 0x5c, 0xc0, 0x0e, 0x98, 0x31, 0x72,
	0x0e, 0xc7, 0x15, 0x99, 0xd1, 0x39, 0x66, 0x36, 0x3b, 0x3f, 0xee, 0x39, 0xec, 0x63, 0x09, 0x91,
	0xa7, 0x30, 0xa8, 0x24, 0x52, 0x09, 0x5b, 0x82, 0x96, 0x15, 0xf5, 0x1d, 0xfa, 0xd9, 0x81, 0xe4,
	0x19, 0x90, 0x4a, 0xc6, 0x50, 0xa7, 0x8a, 0xcb, 0x5d, 0x70, 0x7e, 0x7c, 0xe2, 0x98, 0xe9, 0x9e,
	0x88, 0x7e, 0x78, 0xd0, 0x8b, 0xab, 0xa2, 0x94, 0xb5, 0xb8, 0xdd, 0x24, 0xef, 0x4e, 0x93, 0xc8,
	0x19, 0x74, 0x0b, 0x8d, 0xea, 0xb0, 0x24, 0xf5, 0x5c, 0x72, 0x0a, 0xb5, 0x28, 0x54, 0x8a, 0xb5,
	0xbf, 0x7a, 0x26, 0xa7, 0xd0, 0xae, 0x9e, 0xd0, 0x39, 0xab, 0xa6, 0xf2, 0x77, 0x5c, 0x26, 0x94,
	0x31, 0xb5, 0x37, 0xe4, 0x73, 0xf9, 0xd2, 0x01, 0xe5, 0x4a, 0xcc, 0x99, 0x14, 0x3c, 0x37, 0x95,
	0x85, 0xdd, 0x7c, 0xf1, 0x01, 0x3a, 0xaf, 0xdd, 0xcd, 0x90, 0x17, 0x30, 0x2c, 0x3f, 0xcb, 0xfe,
	0x1c, 0x3c, 0x1e, 0x19, 0x4c, 0xea, 0x1b, 0xb3, 0x17, 0x75, 0xf6, 0x60, 0x37, 0xdf, 0x3e, 0xac,
	0xa8, 0xf1, 0xea, 0xfc, 0xe7, 0x26, 0xf4, 0x6e, 0x36, 0xa1, 0xf7, 0x7b, 0x13, 0x7a, 0xdf, 0xb6,
	0x61, 0xe3, 0x66, 0x1b, 0x36, 0x7e, 0x6d, 0xc3, 0xc6, 0x97, 0xfa, 0x30, 0xe7, 0x6d, 0x7b, 0xa8,
	0xcf, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0x2e, 0xc1, 0xba, 0x5d, 0xb9, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CopyftoClient is the client API for Copyfto service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CopyftoClient interface {
	// swagger:operation POST /api/template/Template/GetParticipantById CopyFTO CopyFileDummyOrder
	// GetParticipantById
	// ---
	// responses:
	//   "200":
	//     description: Success message. Value is 1 if its active, otherwise no active account registered.
	//     in: body
	//     schema:
	//       "$ref": "#/definitions/Empty"
	//   "500":
	//     description: error message
	//     examples:
	//       error-message: missing-participant-id
	//     schema:
	//       type: object
	//       properties:
	//          error-message:
	//              type: string
	//          timestamp:
	//              type: integer
	//          bus-id:
	//              type: string
	//
	// parameters:
	// - in: body
	//   name: Request Body
	//   schema:
	//     "$ref": "#/definitions/Id"
	//   required: true
	CopyFileDummyOrder(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GenericReponse, error)
}

type copyftoClient struct {
	cc *grpc.ClientConn
}

func NewCopyftoClient(cc *grpc.ClientConn) CopyftoClient {
	return &copyftoClient{cc}
}

func (c *copyftoClient) CopyFileDummyOrder(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GenericReponse, error) {
	out := new(GenericReponse)
	err := c.cc.Invoke(ctx, "/copyfto.Copyfto/CopyFileDummyOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CopyftoServer is the server API for Copyfto service.
type CopyftoServer interface {
	// swagger:operation POST /api/template/Template/GetParticipantById CopyFTO CopyFileDummyOrder
	// GetParticipantById
	// ---
	// responses:
	//   "200":
	//     description: Success message. Value is 1 if its active, otherwise no active account registered.
	//     in: body
	//     schema:
	//       "$ref": "#/definitions/Empty"
	//   "500":
	//     description: error message
	//     examples:
	//       error-message: missing-participant-id
	//     schema:
	//       type: object
	//       properties:
	//          error-message:
	//              type: string
	//          timestamp:
	//              type: integer
	//          bus-id:
	//              type: string
	//
	// parameters:
	// - in: body
	//   name: Request Body
	//   schema:
	//     "$ref": "#/definitions/Id"
	//   required: true
	CopyFileDummyOrder(context.Context, *Empty) (*GenericReponse, error)
}

// UnimplementedCopyftoServer can be embedded to have forward compatible implementations.
type UnimplementedCopyftoServer struct {
}

func (*UnimplementedCopyftoServer) CopyFileDummyOrder(ctx context.Context, req *Empty) (*GenericReponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CopyFileDummyOrder not implemented")
}

func RegisterCopyftoServer(s *grpc.Server, srv CopyftoServer) {
	s.RegisterService(&_Copyfto_serviceDesc, srv)
}

func _Copyfto_CopyFileDummyOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CopyftoServer).CopyFileDummyOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/copyfto.Copyfto/CopyFileDummyOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CopyftoServer).CopyFileDummyOrder(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _Copyfto_serviceDesc = grpc.ServiceDesc{
	ServiceName: "copyfto.Copyfto",
	HandlerType: (*CopyftoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CopyFileDummyOrder",
			Handler:    _Copyfto_CopyFileDummyOrder_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "copyfto.proto",
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Empty) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GenericReponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenericReponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenericReponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintCopyfto(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DummyOrderInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DummyOrderInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DummyOrderInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FileStatus) > 0 {
		i -= len(m.FileStatus)
		copy(dAtA[i:], m.FileStatus)
		i = encodeVarintCopyfto(dAtA, i, uint64(len(m.FileStatus)))
		i--
		dAtA[i] = 0x42
	}
	if m.ObtainedDate != 0 {
		i = encodeVarintCopyfto(dAtA, i, uint64(m.ObtainedDate))
		i--
		dAtA[i] = 0x38
	}
	if m.NumberOfTransaction != 0 {
		i = encodeVarintCopyfto(dAtA, i, uint64(m.NumberOfTransaction))
		i--
		dAtA[i] = 0x30
	}
	if m.ZipFileSize != 0 {
		i = encodeVarintCopyfto(dAtA, i, uint64(m.ZipFileSize))
		i--
		dAtA[i] = 0x28
	}
	if m.NormalFileSize != 0 {
		i = encodeVarintCopyfto(dAtA, i, uint64(m.NormalFileSize))
		i--
		dAtA[i] = 0x20
	}
	if m.FileNumber != 0 {
		i = encodeVarintCopyfto(dAtA, i, uint64(m.FileNumber))
		i--
		dAtA[i] = 0x18
	}
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintCopyfto(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCopyfto(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DummyOrderInfoHistory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DummyOrderInfoHistory) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DummyOrderInfoHistory) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StatusDescription) > 0 {
		i -= len(m.StatusDescription)
		copy(dAtA[i:], m.StatusDescription)
		i = encodeVarintCopyfto(dAtA, i, uint64(len(m.StatusDescription)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.StatusProcess) > 0 {
		i -= len(m.StatusProcess)
		copy(dAtA[i:], m.StatusProcess)
		i = encodeVarintCopyfto(dAtA, i, uint64(len(m.StatusProcess)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.StatusLabel) > 0 {
		i -= len(m.StatusLabel)
		copy(dAtA[i:], m.StatusLabel)
		i = encodeVarintCopyfto(dAtA, i, uint64(len(m.StatusLabel)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.StatusId) > 0 {
		i -= len(m.StatusId)
		copy(dAtA[i:], m.StatusId)
		i = encodeVarintCopyfto(dAtA, i, uint64(len(m.StatusId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DummyOrderDetail) > 0 {
		i -= len(m.DummyOrderDetail)
		copy(dAtA[i:], m.DummyOrderDetail)
		i = encodeVarintCopyfto(dAtA, i, uint64(len(m.DummyOrderDetail)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintCopyfto(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintCopyfto(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.IpAddress) > 0 {
		i -= len(m.IpAddress)
		copy(dAtA[i:], m.IpAddress)
		i = encodeVarintCopyfto(dAtA, i, uint64(len(m.IpAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Action) > 0 {
		i -= len(m.Action)
		copy(dAtA[i:], m.Action)
		i = encodeVarintCopyfto(dAtA, i, uint64(len(m.Action)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Resource) > 0 {
		i -= len(m.Resource)
		copy(dAtA[i:], m.Resource)
		i = encodeVarintCopyfto(dAtA, i, uint64(len(m.Resource)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintCopyfto(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintCopyfto(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCopyfto(dAtA []byte, offset int, v uint64) int {
	offset -= sovCopyfto(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Empty) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GenericReponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovCopyfto(uint64(l))
	}
	return n
}

func (m *DummyOrderInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCopyfto(uint64(l))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovCopyfto(uint64(l))
	}
	if m.FileNumber != 0 {
		n += 1 + sovCopyfto(uint64(m.FileNumber))
	}
	if m.NormalFileSize != 0 {
		n += 1 + sovCopyfto(uint64(m.NormalFileSize))
	}
	if m.ZipFileSize != 0 {
		n += 1 + sovCopyfto(uint64(m.ZipFileSize))
	}
	if m.NumberOfTransaction != 0 {
		n += 1 + sovCopyfto(uint64(m.NumberOfTransaction))
	}
	if m.ObtainedDate != 0 {
		n += 1 + sovCopyfto(uint64(m.ObtainedDate))
	}
	l = len(m.FileStatus)
	if l > 0 {
		n += 1 + l + sovCopyfto(uint64(l))
	}
	return n
}

func (m *DummyOrderInfoHistory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovCopyfto(uint64(l))
	}
	l = len(m.DummyOrderDetail)
	if l > 0 {
		n += 1 + l + sovCopyfto(uint64(l))
	}
	l = len(m.StatusId)
	if l > 0 {
		n += 1 + l + sovCopyfto(uint64(l))
	}
	l = len(m.StatusLabel)
	if l > 0 {
		n += 1 + l + sovCopyfto(uint64(l))
	}
	l = len(m.StatusProcess)
	if l > 0 {
		n += 1 + l + sovCopyfto(uint64(l))
	}
	l = len(m.StatusDescription)
	if l > 0 {
		n += 1 + l + sovCopyfto(uint64(l))
	}
	return n
}

func (m *RequestInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovCopyfto(uint64(l))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovCopyfto(uint64(l))
	}
	l = len(m.Resource)
	if l > 0 {
		n += 1 + l + sovCopyfto(uint64(l))
	}
	l = len(m.Action)
	if l > 0 {
		n += 1 + l + sovCopyfto(uint64(l))
	}
	l = len(m.IpAddress)
	if l > 0 {
		n += 1 + l + sovCopyfto(uint64(l))
	}
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovCopyfto(uint64(l))
	}
	return n
}

func sovCopyfto(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCopyfto(x uint64) (n int) {
	return sovCopyfto(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopyfto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCopyfto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopyfto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCopyfto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenericReponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopyfto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenericReponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenericReponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopyfto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopyfto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCopyfto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCopyfto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopyfto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopyfto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCopyfto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DummyOrderInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopyfto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DummyOrderInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DummyOrderInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopyfto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCopyfto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCopyfto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopyfto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCopyfto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCopyfto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileNumber", wireType)
			}
			m.FileNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopyfto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileNumber |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NormalFileSize", wireType)
			}
			m.NormalFileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopyfto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NormalFileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZipFileSize", wireType)
			}
			m.ZipFileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopyfto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ZipFileSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumberOfTransaction", wireType)
			}
			m.NumberOfTransaction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopyfto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumberOfTransaction |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObtainedDate", wireType)
			}
			m.ObtainedDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopyfto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ObtainedDate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopyfto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCopyfto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCopyfto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopyfto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopyfto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCopyfto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DummyOrderInfoHistory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopyfto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DummyOrderInfoHistory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DummyOrderInfoHistory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopyfto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCopyfto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCopyfto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DummyOrderDetail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopyfto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCopyfto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCopyfto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DummyOrderDetail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopyfto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCopyfto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCopyfto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopyfto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCopyfto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCopyfto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusProcess", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopyfto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCopyfto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCopyfto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusProcess = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusDescription", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopyfto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCopyfto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCopyfto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusDescription = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopyfto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopyfto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCopyfto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCopyfto
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopyfto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCopyfto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCopyfto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopyfto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCopyfto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCopyfto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopyfto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCopyfto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCopyfto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resource = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopyfto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCopyfto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCopyfto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopyfto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCopyfto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCopyfto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCopyfto
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCopyfto
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCopyfto
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCopyfto(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCopyfto
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCopyfto
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCopyfto(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCopyfto
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCopyfto
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCopyfto
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCopyfto
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthCopyfto
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowCopyfto
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipCopyfto(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthCopyfto
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthCopyfto = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCopyfto   = fmt.Errorf("proto: integer overflow")
)
